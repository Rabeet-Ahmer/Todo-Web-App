# Backend Development Rules

## Architecture Overview: Better Auth + FastAPI Hybrid

**This backend works in conjunction with Better Auth (Next.js/TypeScript) as follows:**

```
┌─────────────────────────────────────────────────┐
│              Next.js Frontend                   │
│         (Better Auth + UI Components)           │
└─────────────────────────────────────────────────┘
                     │
         ┌───────────┴───────────┐
         │                       │
         ▼                       ▼
┌────────────────┐      ┌────────────────┐
│  Better Auth   │      │   FastAPI      │
│  - Users table │      │  - Todos table │
│  - Sessions    │◄─────┤  - Validates   │
│  - JWT + Cookie│      │    JWT token   │
└────────────────┘      └────────────────┘
         │                       │
         └───────────┬───────────┘
                     │
                     ▼
              ┌──────────────┐
              │ PostgreSQL   │
              │              │
              │ users        │ ← Better Auth owns this
              │ sessions     │ ← Better Auth owns this
              │ todos        │ ← FastAPI owns this (FK to users)
              └──────────────┘
```

**Key Architectural Decisions:**
- **Better Auth handles authentication ONLY**: User registration, login, password hashing, session management, JWT generation
- **FastAPI handles business logic ONLY**: Todo CRUD, validates JWT tokens from Better Auth
- **Both connect to same PostgreSQL database**: Different tables but shared foreign keys
- **Shared JWT secret**: Both use the same secret for token validation
- **Frontend bridges both**: Extracts JWT from Better Auth cookie → Sends to FastAPI

**What FastAPI Does NOT Do:**
- ❌ Does NOT generate JWT tokens (Better Auth does this)
- ❌ Does NOT hash passwords (Better Auth does this)
- ❌ Does NOT create users (Better Auth does this)
- ❌ Does NOT manage sessions (Better Auth does this)

**What FastAPI DOES Do:**
- ✅ Validates JWT tokens from Better Auth
- ✅ Queries Better Auth's `users` table to verify users exist
- ✅ Handles all business logic (todos CRUD)
- ✅ Stores todos with `user_id` foreign key to Better Auth's users table

---

## FastAPI Architecture Patterns

### 1. API Route Structure
- All routes use `/api/v1/` prefix (e.g., `/api/v1/todos`)
- **NO auth/login endpoints** - Better Auth handles signup/login
- Use `Depends()` for shared dependencies (auth, DB session, CORS)
- Status codes must follow REST conventions:
  - 200/201: Success (GET/POST)
  - 400: Validation errors (Pydantic validation failures)
  - 401: Authentication failures (invalid/missing token)
  - 403: Authorization failures (insufficient permissions)
  - 404: Not found
  - 422: Unprocessable entity (Pydantic validation)
  - 500: Server errors

### 2. JWT Validation with FastAPI

**Architecture Note:**
FastAPI does NOT generate tokens. It only VALIDATES tokens generated by Better Auth.

**Security Scheme Pattern:**
```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from typing import Annotated

# HTTPBearer extracts "Authorization: Bearer <token>" header
security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    session: Annotated[AsyncSession, Depends(get_session)]
) -> User:
    """Validate JWT token from Better Auth and return current user."""
    if not credentials.credentials:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Missing authentication token",
            headers={"WWW-Authenticate": "Bearer"},
        )

    token = credentials.credentials

    try:
        # 1. Decode JWT signature using SHARED secret
        payload = jwt.decode(
            token,
            SECRET_KEY,  # Same secret as Better Auth!
            algorithms=[ALGORITHM]
        )

        # 2. Extract user_id from JWT payload ("sub" claim)
        user_id = payload.get("sub")

        if user_id is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token payload"
            )

        # 3. Convert user_id to integer (Better Auth stores as string in JWT)
        try:
            user_id = int(user_id)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid user ID in token"
            )

        # 4. Query Better Auth's users table to verify user exists
        statement = select(User).where(User.id == user_id)
        results = await session.exec(statement)
        user = results.one_or_none()

        if user is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found in database"
            )

        return user

    except JWTError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Invalid token: {str(e)}",
            headers={"WWW-Authenticate": "Bearer"},
        )
```

**Protected Route Example:**
```python
from fastapi import Depends
from typing import Annotated

@app.get("/api/v1/todos")
async def get_todos(
    current_user: Annotated[User, Depends(get_current_user)],
    session: Annotated[AsyncSession, Depends(get_session)]
) -> list[TodoResponse]:
    """Get all todos for authenticated user."""

    # Only fetch todos belonging to this user
    statement = select(Todo).where(Todo.user_id == current_user.id)
    results = await session.exec(statement)
    todos = results.all()

    return [TodoResponse.model_validate(todo) for todo in todos]

@app.post("/api/v1/todos")
async def create_todo(
    todo_create: TodoCreate,
    current_user: Annotated[User, Depends(get_current_user)],
    session: Annotated[AsyncSession, Depends(get_session)]
) -> TodoResponse:
    """Create a todo for authenticated user."""

    todo = Todo(
        title=todo_create.title,
        description=todo_create.description,
        user_id=current_user.id  # Link to Better Auth's user
    )

    session.add(todo)
    await session.commit()
    await session.refresh(todo)

    return TodoResponse.model_validate(todo)

@app.patch("/api/v1/todos/{todo_id}")
async def update_todo(
    todo_id: int,
    todo_update: TodoUpdate,
    current_user: Annotated[User, Depends(get_current_user)],
    session: Annotated[AsyncSession, Depends(get_session)]
) -> TodoResponse:
    """Update a todo (must belong to authenticated user)."""

    # Fetch todo and verify ownership
    statement = select(Todo).where(
        Todo.id == todo_id,
        Todo.user_id == current_user.id  # Security: User owns this todo
    )
    results = await session.exec(statement)
    todo = results.one_or_none()

    if todo is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Todo not found"
        )

    # Update fields
    todo_data = todo_update.model_dump(exclude_unset=True)
    for field, value in todo_data.items():
        setattr(todo, field, value)

    await session.commit()
    await session.refresh(todo)

    return TodoResponse.model_validate(todo)
```

### 3. User Model (Read-Only from Better Auth's Table)

**Important: FastAPI has READ-ONLY access to Better Auth's user table.**

```python
# app/models/user.py
from sqlmodel import Field, SQLModel
from typing import Optional

# This matches Better Auth's user table schema
# Better Auth creates this table automatically
class User(SQLModel, table=True):
    """
    User model matching Better Auth's schema.
    Better Auth owns this table; FastAPI only reads it.
    """
    id: Optional[int] = Field(default=None, primary_key=True)
    email: str = Field(index=True, unique=True, max_length=255)
    email_verified: bool = Field(default=False)
    name: Optional[str] = Field(default=None, max_length=255)
    image: Optional[str] = Field(default=None)
    created_at: str = Field(default_factory=lambda: datetime.utcnow().isoformat())
    updated_at: str = Field(default_factory=lambda: datetime.utcnow().isoformat())
```

### 4. Pydantic v2 Schema Conventions

**Separation of Concerns:**
- `models/`: SQLModel for database (FastAPI's tables: todos)
- `models/user.py`: SQLModel for read-only access to Better Auth's users table
- `schemas/`: Pydantic for API contracts (inherit from `BaseModel`)

**Schema Naming Conventions:**
- `*Create`: Input for creation (all required fields)
- `*Update`: Partial input with `Optional` fields (for PATCH)
- `*Response`: Output representation

**Pydantic v2 Configuration:**
```python
from pydantic import BaseModel, ConfigDict, Field

class TodoCreate(BaseModel):
    """Schema for creating a todo."""
    title: str = Field(min_length=1, max_length=200)
    description: Optional[str] = Field(default=None, max_length=1000)

class TodoUpdate(BaseModel):
    """Schema for updating a todo (all fields optional)."""
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)
    is_completed: Optional[bool] = None

class TodoResponse(BaseModel):
    """Schema for todo response."""
    model_config = ConfigDict(from_attributes=True)  # Pydantic v2

    id: int
    title: str
    description: Optional[str] = None
    is_completed: bool
    user_id: int
    created_at: str
    updated_at: str

class UserResponse(BaseModel):
    """Schema for user response (from Better Auth's table)."""
    model_config = ConfigDict(from_attributes=True)  # Pydantic v2

    id: int
    email: str
    name: Optional[str] = None
    created_at: str
```

### 5. Service Layer Pattern

**Layered Architecture:**
```
API Routes (api/v1/*) → Services (services/*) → Database (db/*)
```

**Service Layer Rules:**
- All business logic lives in `services/`
- API routes only handle HTTP concerns (status codes, parsing, validation)
- Services accept DB session and perform CRUD operations
- Services raise custom exceptions from `core/exceptions.py`
- Services must be async for all I/O operations
- **No auth logic** in services (Better Auth handles this)

**Service Example:**
```python
# app/services/todo_service.py
from sqlmodel import select
from sqlmodel.ext.asyncio.session import AsyncSession
from typing import Optional

class TodoService:
    async def create_todo(
        self,
        todo_create: TodoCreate,
        user_id: int,
        session: AsyncSession
    ) -> Todo:
        """Create a new todo for user."""
        todo = Todo.model_validate(todo_create)
        todo.user_id = user_id
        session.add(todo)
        await session.commit()
        await session.refresh(todo)
        return todo

    async def get_todos(
        self,
        user_id: int,
        session: AsyncSession,
        skip: int = 0,
        limit: int = 100
    ) -> list[Todo]:
        """Get all todos for user with pagination."""
        statement = (
            select(Todo)
            .where(Todo.user_id == user_id)
            .offset(skip)
            .limit(limit)
            .order_by(Todo.created_at.desc())
        )
        results = await session.exec(statement)
        return results.all()

    async def get_todo_by_id(
        self,
        todo_id: int,
        user_id: int,
        session: AsyncSession
    ) -> Optional[Todo]:
        """Get a specific todo (must belong to user)."""
        statement = select(Todo).where(
            Todo.id == todo_id,
            Todo.user_id == user_id  # Security check
        )
        results = await session.exec(statement)
        return results.one_or_none()

    async def update_todo(
        self,
        todo_id: int,
        todo_update: TodoUpdate,
        user_id: int,
        session: AsyncSession
    ) -> Optional[Todo]:
        """Update a todo."""
        todo = await self.get_todo_by_id(todo_id, user_id, session)

        if not todo:
            return None

        todo_data = todo_update.model_dump(exclude_unset=True)
        for field, value in todo_data.items():
            setattr(todo, field, value)

        await session.commit()
        await session.refresh(todo)
        return todo

    async def delete_todo(
        self,
        todo_id: int,
        user_id: int,
        session: AsyncSession
    ) -> bool:
        """Delete a todo."""
        todo = await self.get_todo_by_id(todo_id, user_id, session)

        if not todo:
            return False

        await session.delete(todo)
        await session.commit()
        return True
```

### 6. SQLModel Async Database Patterns

**Async Engine and Session:**
```python
# app/db/session.py
from sqlalchemy.ext.asyncio import create_async_engine
from sqlmodel.ext.asyncio.session import AsyncSession as SQLModelAsyncSession
from contextlib import asynccontextmanager

# Use async engine (Neon PostgreSQL requires async driver)
async_engine = create_async_engine(
    os.getenv("DATABASE_URL"),  # PostgreSQL connection string
    echo=False,
    pool_pre_ping=True,
    pool_size=10,
    max_overflow=20
)

@asynccontextmanager
async def get_session() -> AsyncGenerator[AsyncSession, None]:
    """Dependency for getting async DB session."""
    async with SQLModelAsyncSession(async_engine) as session:
        yield session
```

**Todo Model (FastAPI owns this table):**
```python
# app/models/todo.py
from sqlmodel import Field, SQLModel
from datetime import datetime
from typing import Optional

class Todo(SQLModel, table=True):
    """
    Todo model owned by FastAPI.
    user_id is a foreign key to Better Auth's users table.
    """
    id: Optional[int] = Field(default=None, primary_key=True)
    title: str = Field(index=True, max_length=200)
    description: Optional[str] = Field(default=None, max_length=1000)
    is_completed: bool = Field(default=False)
    user_id: int = Field(
        foreign_key="user.id",  # FK to Better Auth's users table
        index=True
    )
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

**Database Schema Overview:**
```sql
-- Better Auth tables (created automatically)
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    email_verified BOOLEAN DEFAULT FALSE,
    name VARCHAR(255),
    image TEXT,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE sessions (
    id VARCHAR(255) PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    expires_at TIMESTAMP
);

-- FastAPI tables
CREATE TABLE todos (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    description TEXT,
    is_completed BOOLEAN DEFAULT FALSE,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,  -- FK to Better Auth's users!
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_todos_user_id ON todos(user_id);
CREATE INDEX idx_todos_created_at ON todos(created_at);
```

**Async Query Patterns:**
```python
from sqlmodel import select
from typing import Optional

# SELECT with foreign key filtering
async def get_user_todos(
    user_id: int,
    session: AsyncSession
) -> list[Todo]:
    statement = select(Todo).where(Todo.user_id == user_id)
    results = await session.exec(statement)
    return results.all()

# SELECT with multiple conditions
async def search_todos(
    user_id: int,
    completed: bool | None = None,
    session: AsyncSession
) -> list[Todo]:
    statement = select(Todo).where(Todo.user_id == user_id)

    if completed is not None:
        statement = statement.where(Todo.is_completed == completed)

    statement = statement.order_by(Todo.created_at.desc())
    results = await session.exec(statement)
    return results.all()

# UPDATE with Pydantic v2
async def update_todo_from_schema(
    todo_id: int,
    todo_update: TodoUpdate,
    session: AsyncSession
) -> Optional[Todo]:
    statement = select(Todo).where(Todo.id == todo_id)
    results = await session.exec(statement)
    todo = results.one_or_none()

    if todo:
        # Pydantic v2: model_dump() instead of dict()
        todo_data = todo_update.model_dump(exclude_unset=True)

        for field, value in todo_data.items():
            setattr(todo, field, value)

        await session.commit()
        await session.refresh(todo)

    return todo
```

### 7. Error Handling

**Custom Exceptions (core/exceptions.py):**
```python
class AppException(Exception):
    """Base application exception."""
    pass

class NotFoundException(AppException):
    """Resource not found exception."""
    pass

class UnauthorizedException(AppException):
    """Unauthorized access exception."""
    pass

class ValidationException(AppException):
    """Validation error exception."""
    pass
```

**HTTP Exception Wrapper:**
```python
from fastapi import HTTPException, status

def handle_app_exception(exc: AppException) -> HTTPException:
    """Convert custom exceptions to HTTP exceptions."""
    if isinstance(exc, NotFoundException):
        return HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(exc)
        )
    elif isinstance(exc, UnauthorizedException):
        return HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=str(exc),
            headers={"WWW-Authenticate": "Bearer"}
        )
    elif isinstance(exc, ValidationException):
        return HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(exc)
        )
    else:
        return HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error"
        )
```

### 8. Security Configuration

**Environment Variables (.env):**
```bash
# Shared with Better Auth (MUST be identical)
JWT_SECRET_KEY="super-secret-key-123"

# Database (shared with Better Auth's Prisma)
DATABASE_URL="postgresql+asyncpg://user:pass@host/dbname"

# FastAPI-specific
API_V1_PREFIX="/api/v1"
```

**JWT Validation Settings (core/security.py):**
```python
import os
from jose import JWTError, jwt

# CRITICAL: Must match Better Auth's secret exactly
SECRET_KEY = os.getenv("JWT_SECRET_KEY")
ALGORITHM = "HS256"

def decode_token(token: str) -> dict:
    """
    Verify JWT token signature and return payload.
    This uses the SAME secret as Better Auth.
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token",
            headers={"WWW-Authenticate": "Bearer"},
        )
```

**CORS Configuration (core/middleware.py):**
```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # Frontend URL
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

**Important Security Notes:**
- **NO password hashing in FastAPI** - Better Auth handles this
- **NO user creation in FastAPI** - Better Auth handles this
- **JWT secret must be shared** between Better Auth and FastAPI
- **All routes must require authentication** except health checks

### 9. Environment Configuration (config.py)

```python
from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    """Application settings with environment variables."""
    database_url: str
    jwt_secret_key: str  # Same as Better Auth!
    jwt_algorithm: str = "HS256"

    # Neon PostgreSQL
    pool_size: int = 10
    max_overflow: int = 20

    class Config:
        env_file = ".env"
        case_sensitive = False

settings = Settings()
```

### 10. Performance Targets

- **P95 API response**: <100ms
- **Use `async def` for all I/O operations** (DB, external APIs)
- **Connection pooling**: Neon PostgreSQL with `pool_size=10`, `max_overflow=20`
- **Query optimization**:
  - Prevent N+1 queries with eager loading
  - Use indexes on frequently queried fields (`user_id`, `created_at`)
  - Limit results with pagination (`skip`, `limit`)
  - Use `select().where()` for efficient filtering

### 11. Type Safety Rules

- **No `from typing import Any` allowed**
- All functions must have return type annotations
- Use `Optional[T]` for nullable fields, not `None` defaults in function signatures
- SQLModel types must match Pydantic schemas
- Use `Annotated[Type, Depends()]` for dependencies (FastAPI best practice)
- Use `list[T]` instead of `List[T]` (Python 3.9+)

### 12. File Organization Rules

**Backend Module Organization:**
1. **Layered architecture**: API → Service → DB (clear separation of concerns)
2. **Models vs Schemas**: SQLModel for DB (`models/`), Pydantic schemas for API contracts (`schemas/`)
3. **Version API routes**: Use `/api/v1/` prefix for all endpoints
4. **Dependency injection**: Use FastAPI's dependency system (in `deps.py`)
5. **Async everywhere**: All database operations must be async
6. **Snake_case files**: `todo_service.py`, `todo.py`, `user.py`

**Directory Structure:**
```
backend/
├── app/
│   ├── api/v1/          # API routes
│   │   ├── __init__.py
│   │   ├── router.py       # Main v1 router
│   │   ├── todos.py        # Todo endpoints
│   │   └── deps.py         # Dependencies (get_current_user, get_session)
│   ├── models/          # SQLModel database models
│   │   ├── __init__.py
│   │   ├── todo.py         # Todo model (owned by FastAPI)
│   │   └── user.py         # User model (read-only, Better Auth's table)
│   ├── schemas/         # Pydantic schemas
│   │   ├── __init__.py
│   │   ├── todo.py         # Todo schemas
│   │   └── common.py       # Common schemas (ErrorResponse)
│   ├── services/        # Business logic
│   │   ├── __init__.py
│   │   └── todo_service.py # Todo CRUD operations
│   ├── core/            # Utilities
│   │   ├── __init__.py
│   │   ├── security.py     # JWT validation
│   │   ├── exceptions.py   # Custom exceptions
│   │   └── middleware.py   # CORS
│   └── db/              # Database
│       ├── __init__.py
│       └── session.py     # Async session factory
├── .venv/              # Virtual env (gitignored)
├── .python-version       # Python version (3.13)
├── pyproject.toml        # UV/Poetry dependencies
├── uv.lock              # UV lock file
├── .env                 # Environment variables (gitignored)
├── .env.example          # Example env file
├── .gitignore
└── README.md
```

### 13. Complete API Router Example

```python
# app/api/v1/router.py
from fastapi import APIRouter, Depends
from typing import Annotated

from app.models.todo import Todo
from app.models.user import User
from app.schemas.todo import (
    TodoCreate,
    TodoUpdate,
    TodoResponse
)
from app.api.v1.deps import get_current_user, get_session

router = APIRouter(prefix="/api/v1", tags=["todos"])

@router.get("/todos", response_model=list[TodoResponse])
async def get_todos(
    current_user: Annotated[User, Depends(get_current_user)],
    session: Annotated[AsyncSession, Depends(get_session)]
) -> list[TodoResponse]:
    """Get all todos for authenticated user."""
    # ... implementation

@router.post("/todos", response_model=TodoResponse, status_code=201)
async def create_todo(
    todo_create: TodoCreate,
    current_user: Annotated[User, Depends(get_current_user)],
    session: Annotated[AsyncSession, Depends(get_session)]
) -> TodoResponse:
    """Create a todo for authenticated user."""
    # ... implementation

@router.get("/todos/{todo_id}", response_model=TodoResponse)
async def get_todo(
    todo_id: int,
    current_user: Annotated[User, Depends(get_current_user)],
    session: Annotated[AsyncSession, Depends(get_session)]
) -> TodoResponse:
    """Get a specific todo."""
    # ... implementation

@router.patch("/todos/{todo_id}", response_model=TodoResponse)
async def update_todo(
    todo_id: int,
    todo_update: TodoUpdate,
    current_user: Annotated[User, Depends(get_current_user)],
    session: Annotated[AsyncSession, Depends(get_session)]
) -> TodoResponse:
    """Update a todo."""
    # ... implementation

@router.delete("/todos/{todo_id}", status_code=204)
async def delete_todo(
    todo_id: int,
    current_user: Annotated[User, Depends(get_current_user)],
    session: Annotated[AsyncSession, Depends(get_session)]
) -> None:
    """Delete a todo."""
    # ... implementation
```

### 14. Dependencies File (app/api/v1/deps.py)

```python
from typing import Annotated, AsyncGenerator

from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import JWTError, jwt
from sqlmodel import select

from app.models.user import User
from app.db.session import async_engine, get_session

# Shared settings
SECRET_KEY = os.getenv("JWT_SECRET_KEY")
ALGORITHM = "HS256"

# Security scheme
security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    session: AsyncSession = Depends(get_session)
) -> User:
    """Validate JWT token and return current user."""
    if not credentials.credentials:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Missing authentication token",
            headers={"WWW-Authenticate": "Bearer"},
        )

    try:
        payload = jwt.decode(
            credentials.credentials,
            SECRET_KEY,
            algorithms=[ALGORITHM]
        )
        user_id = payload.get("sub")

        if user_id is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token payload"
            )

        try:
            user_id = int(user_id)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid user ID"
            )

        # Query user from Better Auth's table
        statement = select(User).where(User.id == user_id)
        results = await session.exec(statement)
        user = results.one_or_none()

        if user is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found"
            )

        return user

    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token",
            headers={"WWW-Authenticate": "Bearer"},
        )
```

---

## Summary: Better Auth + FastAPI Architecture

### **What Better Auth Does:**
- User registration and login
- Password hashing and storage
- Session management
- JWT token generation
- Cookie setting (httpOnly)
- Owns `users` and `sessions` tables

### **What FastAPI Does:**
- Validates JWT tokens (using shared secret)
- Queries Better Auth's `users` table to verify users
- Handles all business logic (todos CRUD)
- Stores todos with `user_id` foreign key to users table
- Enforces authorization (user can only access their own todos)

### **What Frontend Does:**
- Extracts JWT token from Better Auth cookie
- Sends JWT to FastAPI in Authorization header
- Handles UI for auth and business features
- Bridges Better Auth and FastAPI

### **Critical Requirements:**
1. **Shared JWT secret** between Better Auth and FastAPI
2. **Same PostgreSQL database** for both
3. **Foreign key** from todos to users table
4. **FastAPI validates** every request with JWT
5. **Better Auth manages** auth flow (signup/login/logout)
